{-# LANGUAGE ForeignFunctionInterface #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE UndecidableInstances #-}

-- This file was generated by stechec2-generator. DO NOT EDIT.

module CApi where

import Data.List (foldl')
import Foreign
import Foreign.C.String
import Foreign.C.Types
import Foreign.Marshal.Array

#include "api.h"

class ApiStorable a where
  type ApiStorableType a
  toStorable :: a -> (ApiStorableType a -> IO b) -> IO b
  unStorable :: ApiStorableType a -> IO a
  type ApiStorableBaseType a
  toStorableBase :: a -> (ApiStorableBaseType a -> IO b) -> IO b
  unStorableBase :: ApiStorableBaseType a -> IO a

instance ApiStorable () where
  type ApiStorableType () = ()
  toStorable () f = f ()
  {-# INLINE toStorable #-}
  unStorable _ = return ()
  {-# INLINE unStorable #-}
  type ApiStorableBaseType () = ()
  toStorableBase = toStorable
  {-# INLINE toStorableBase #-}
  unStorableBase = unStorable
  {-# INLINE unStorableBase #-}

instance ApiStorable Int where
  type ApiStorableType Int = CInt
  toStorable x f = f (fromIntegral x)
  {-# INLINE toStorable #-}
  unStorable = return . fromIntegral
  {-# INLINE unStorable #-}
  type ApiStorableBaseType Int = ApiStorableType Int
  toStorableBase = toStorable
  {-# INLINE toStorableBase #-}
  unStorableBase = unStorable
  {-# INLINE unStorableBase #-}

instance ApiStorable Bool where
  type ApiStorableType Bool = CBool
  toStorable x f = f ((\bx -> if bx then 1 else 0) x)
  {-# INLINE toStorable #-}
  unStorable = return . (/= 0)
  {-# INLINE unStorable #-}
  type ApiStorableBaseType Bool = ApiStorableType Bool
  toStorableBase = toStorable
  {-# INLINE toStorableBase #-}
  unStorableBase = unStorable
  {-# INLINE unStorableBase #-}

instance ApiStorable Double where
  type ApiStorableType Double = CDouble
  toStorable x f = f (CDouble x)
  {-# INLINE toStorable #-}
  unStorable = return . (\(CDouble x) -> x)
  {-# INLINE unStorable #-}
  type ApiStorableBaseType Double = ApiStorableType Double
  toStorableBase = toStorable
  {-# INLINE toStorableBase #-}
  unStorableBase = unStorable
  {-# INLINE unStorableBase #-}

instance ApiStorable String where
  type ApiStorableType String = CString
  toStorable = withCString
  {-# INLINE toStorable #-}
  unStorable = peekCString
  {-# INLINE unStorable #-}
  type ApiStorableBaseType String = ApiStorableType String
  toStorableBase = toStorable
  {-# INLINE toStorableBase #-}
  unStorableBase = unStorable
  {-# INLINE unStorableBase #-}


-- Les actions de jeu
data Action =
    Valider -- Valide une unique carte
  | Defausser -- Défausse deux cartes
  | Choix_trois -- Donne le choix entre trois cartes
  | Choix_paquets -- Donne le choix entre deux paquets de deux cartes
  | Premier_joueur -- Aucune action n'a été jouée (utilisé dans tour_precedent)
  deriving(Show, Eq, Enum)
type CAction = CInt

instance ApiStorable Action where
  type ApiStorableType Action = CInt
  toStorable x f = f (fromIntegral (fromEnum x))
  {-# INLINE toStorable #-}
  unStorable = return . toEnum . fromIntegral
  {-# INLINE unStorable #-}
  type ApiStorableBaseType Action = ApiStorableType Action
  toStorableBase = toStorable
  {-# INLINE toStorableBase #-}
  unStorableBase = unStorable
  {-# INLINE unStorableBase #-}


-- Enumeration contentant toutes les erreurs possibles
data Error =
    Ok -- pas d'erreur
  | Action_deja_jouee -- l'action a déjà été jouée
  | Cartes_invalides -- vous ne pouvez pas jouer ces cartes
  | Paquet_invalide -- ce paquet n'existe pas
  | Geisha_invalides -- cette Geisha n'existe pas (doit être un entier entre 0 et NB_GEISHA - 1)
  | Joueur_invalide -- ce joueur n'existe pas
  | Choix_invalide -- vous ne pouvez pas répondre à ce choix
  | Action_invalide -- vous ne pouvez pas jouer cette action maintenant
  deriving(Show, Eq, Enum)
type CError = CInt

instance ApiStorable Error where
  type ApiStorableType Error = CInt
  toStorable x f = f (fromIntegral (fromEnum x))
  {-# INLINE toStorable #-}
  unStorable = return . toEnum . fromIntegral
  {-# INLINE unStorable #-}
  type ApiStorableBaseType Error = ApiStorableType Error
  toStorableBase = toStorable
  {-# INLINE toStorableBase #-}
  unStorableBase = unStorable
  {-# INLINE unStorableBase #-}


-- Enumeration représentant les différents joueurs
data Joueur =
    Joueur_1 -- Le joueur 1
  | Joueur_2 -- Le joueur 2
  | Egalite -- Égalité, utilisé uniquement dans possession_geisha
  deriving(Show, Eq, Enum)
type CJoueur = CInt

instance ApiStorable Joueur where
  type ApiStorableType Joueur = CInt
  toStorable x f = f (fromIntegral (fromEnum x))
  {-# INLINE toStorable #-}
  unStorable = return . toEnum . fromIntegral
  {-# INLINE unStorable #-}
  type ApiStorableBaseType Joueur = ApiStorableType Joueur
  toStorableBase = toStorable
  {-# INLINE toStorableBase #-}
  unStorableBase = unStorable
  {-# INLINE unStorableBase #-}


-- La description d'une action jouée
data Action_jouee = Action_jouee {
  act :: Action, -- L'action jouée
  c1 :: Int, -- Si act==VALIDER ou act==DEFAUSSER, -1 sinon la première carte (du premier
-- paquet)
  c2 :: Int, -- Si act==V|D: -1 sinon la deuxième carte (du premier paquet)
  c3 :: Int, -- Si act==V|D: -1 sinon la troisième carte (ou la première carte du second
-- paquet si act==choix paquet)
  c4 :: Int -- Si act!=choix paquet: -1 sinon la deuxième carte du second paquet
}

  deriving(Show, Eq)

data CAction_jouee = CAction_jouee {
  cact :: CAction, -- L'action jouée
  cc1 :: CInt, -- Si act==VALIDER ou act==DEFAUSSER, -1 sinon la première carte (du premier
-- paquet)
  cc2 :: CInt, -- Si act==V|D: -1 sinon la deuxième carte (du premier paquet)
  cc3 :: CInt, -- Si act==V|D: -1 sinon la troisième carte (ou la première carte du second
-- paquet si act==choix paquet)
  cc4 :: CInt -- Si act!=choix paquet: -1 sinon la deuxième carte du second paquet
}

instance Storable CAction_jouee where
  sizeOf _ = (#size action_jouee)
  {-# INLINE sizeOf #-}
  alignment _ = alignment (undefined :: CInt)
  {-# INLINE alignment #-}
  peek ptr = do
    aact <- (#peek action_jouee, act) ptr
    ac1 <- (#peek action_jouee, c1) ptr
    ac2 <- (#peek action_jouee, c2) ptr
    ac3 <- (#peek action_jouee, c3) ptr
    ac4 <- (#peek action_jouee, c4) ptr
    return $ CAction_jouee aact ac1 ac2 ac3 ac4
  {-# INLINE peek #-}
  poke ptr (CAction_jouee aact ac1 ac2 ac3 ac4) = do

    (#poke action_jouee, act) ptr aact
    (#poke action_jouee, c1) ptr ac1
    (#poke action_jouee, c2) ptr ac2
    (#poke action_jouee, c3) ptr ac3
    (#poke action_jouee, c4) ptr ac4


  {-# INLINE poke #-}
instance ApiStorable Action_jouee where
  type ApiStorableType Action_jouee = Ptr CAction_jouee
  toStorable (Action_jouee aact ac1 ac2 ac3 ac4) f = toStorableBase aact $ \aact' ->  toStorableBase ac1 $ \ac1' ->  toStorableBase ac2 $ \ac2' ->  toStorableBase ac3 $ \ac3' ->  toStorableBase ac4 $ \ac4' ->  do
    alloca $ \ptr -> do
      poke ptr $ CAction_jouee aact' ac1' ac2' ac3' ac4'
      f ptr

  {-# INLINE toStorable #-}
  unStorable ptr = do
    (CAction_jouee aact' ac1' ac2' ac3' ac4') <- peek ptr
    aact <- unStorableBase aact'
    ac1 <- unStorableBase ac1'
    ac2 <- unStorableBase ac2'
    ac3 <- unStorableBase ac3'
    ac4 <- unStorableBase ac4'
    return $ Action_jouee aact ac1 ac2 ac3 ac4


  {-# INLINE unStorable #-}
  type ApiStorableBaseType Action_jouee = CAction_jouee
  toStorableBase (Action_jouee aact ac1 ac2 ac3 ac4) f =
    toStorableBase aact $ \aact' ->     toStorableBase ac1 $ \ac1' ->     toStorableBase ac2 $ \ac2' ->     toStorableBase ac3 $ \ac3' ->     toStorableBase ac4 $ \ac4' -> f (CAction_jouee  aact' ac1' ac2' ac3' ac4')


  {-# INLINE toStorableBase #-}
  unStorableBase (CAction_jouee  aact' ac1' ac2' ac3' ac4') = do

    aact <- unStorableBase aact'
    ac1 <- unStorableBase ac1'
    ac2 <- unStorableBase ac2'
    ac3 <- unStorableBase ac3'
    ac4 <- unStorableBase ac4'

    return $ Action_jouee  aact ac1 ac2 ac3 ac4
  {-# INLINE unStorableBase #-}



data CInt_array = CInt_array { cInt_arrayPtr :: Ptr CInt, cInt_arraySize :: CSize }

instance Storable CInt_array where
  sizeOf _ = (#size int_array)
  {-# INLINE sizeOf #-}
  alignment _ = alignment (undefined :: CInt)
  {-# INLINE alignment #-}
  peek ptr = do
    length <- (#peek int_array, length) ptr
    items <- (#peek int_array, items) ptr
    return $ CInt_array items length

  {-# INLINE peek #-}
  poke ptr (CInt_array items length) = do
    (#poke int_array, length) ptr length
    (#poke int_array, items) ptr items
  {-# INLINE poke #-}

instance ApiStorable [Int] where
  type ApiStorableType [Int] = Ptr CInt_array
  toStorable xs f = toStorableBase xs $ \a -> alloca $ \ptr -> do
    poke ptr a
    f ptr
  {-# INLINE toStorable #-}
  unStorable xa = do
    (CInt_array xa' xl) <- peek xa
    xs <- peekArray (fromIntegral xl) xa'
    mapM unStorableBase xs
  {-# INLINE unStorable #-}
  type ApiStorableBaseType [Int] = CInt_array

  toStorableBase xs f = do
    let xl = length xs
    allocaArray xl $ \xa ->
      foldl'
        (\acc (i, c) -> toStorableBase c $ \c' -> do
          poke (advancePtr xa i) c'
          acc
        )
        (f $ CInt_array xa (fromIntegral xl))
        (zip [0..] xs)
  {-# INLINE toStorableBase #-}
  unStorableBase (CInt_array xa xl) = do
    xs <- peekArray (fromIntegral xl) xa
    mapM unStorableBase xs
  {-# INLINE unStorableBase #-}


-- Renvoie l'identifiant du joueur
id_joueur ::IO Joueur
id_joueur = (hs_id_joueur ) >>= unStorable


foreign import ccall
  hs_id_joueur ::  IO (ApiStorableType Joueur)
-- Renvoie l'identifiant de l'adversaire
id_adversaire ::IO Joueur
id_adversaire = (hs_id_adversaire ) >>= unStorable


foreign import ccall
  hs_id_adversaire ::  IO (ApiStorableType Joueur)
-- Renvoie le numéro de la manche (entre 0 et 2)
manche ::IO Int
manche = (hs_manche ) >>= unStorable


foreign import ccall
  hs_manche ::  IO (ApiStorableType Int)
-- Renvoie le numéro du tour (entre 0 et 7)
tour ::IO Int
tour = (hs_tour ) >>= unStorable


foreign import ccall
  hs_tour ::  IO (ApiStorableType Int)
-- Renvoie l'action jouée par l'adversaire
tour_precedent ::IO Action_jouee
tour_precedent = (hs_tour_precedent ) >>= unStorable


foreign import ccall
  hs_tour_precedent ::  IO (ApiStorableType Action_jouee)
-- Renvoie le nombre de cartes validées par le joueur pour la Geisha (la carte
-- validée secrètement n'est pas prise en compte)
nb_cartes_validees :: Joueur ->  Int -> IO Int
nb_cartes_validees j  g  = toStorable j $ \j' ->  toStorable g $ \g' ->  (hs_nb_cartes_validees  j' g') >>= unStorable


foreign import ccall
  hs_nb_cartes_validees ::  (ApiStorableType Joueur) -> (ApiStorableType Int) -> IO (ApiStorableType Int)
-- Renvoie qui possède la Geisha
possession_geisha :: Int -> IO Joueur
possession_geisha g  = toStorable g $ \g' ->  (hs_possession_geisha  g') >>= unStorable


foreign import ccall
  hs_possession_geisha ::  (ApiStorableType Int) -> IO (ApiStorableType Joueur)
-- Renvoie si l'action a déjà été jouée par le joueur
est_jouee_action :: Joueur ->  Action -> IO Bool
est_jouee_action j  a  = toStorable j $ \j' ->  toStorable a $ \a' ->  (hs_est_jouee_action  j' a') >>= unStorable


foreign import ccall
  hs_est_jouee_action ::  (ApiStorableType Joueur) -> (ApiStorableType Action) -> IO (ApiStorableType Bool)
-- Renvoie le nombre de cartes que le joueur a
nb_cartes :: Joueur -> IO Int
nb_cartes j  = toStorable j $ \j' ->  (hs_nb_cartes  j') >>= unStorable


foreign import ccall
  hs_nb_cartes ::  (ApiStorableType Joueur) -> IO (ApiStorableType Int)
-- Renvoie les cartes que vous avez
cartes_en_main ::IO [Int]
cartes_en_main = (hs_cartes_en_main ) >>= unStorable


foreign import ccall
  hs_cartes_en_main ::  IO (ApiStorableType [Int])
-- Renvoie la carte que vous avez piochée au début du tour
carte_piochee ::IO Int
carte_piochee = (hs_carte_piochee ) >>= unStorable


foreign import ccall
  hs_carte_piochee ::  IO (ApiStorableType Int)
-- Jouer l'action valider une carte
action_valider :: Int -> IO Error
action_valider c  = toStorable c $ \c' ->  (hs_action_valider  c') >>= unStorable


foreign import ccall
  hs_action_valider ::  (ApiStorableType Int) -> IO (ApiStorableType Error)
-- Jouer l'action défausser deux cartes
action_defausser :: Int ->  Int -> IO Error
action_defausser c1  c2  = toStorable c1 $ \c1' ->  toStorable c2 $ \c2' ->  (hs_action_defausser  c1' c2') >>= unStorable


foreign import ccall
  hs_action_defausser ::  (ApiStorableType Int) -> (ApiStorableType Int) -> IO (ApiStorableType Error)
-- Jouer l'action choisir entre trois cartes
action_choix_trois :: Int ->  Int ->  Int -> IO Error
action_choix_trois c1  c2  c3  = toStorable c1 $ \c1' ->  toStorable c2 $ \c2' ->  toStorable c3 $ \c3' ->  (hs_action_choix_trois  c1' c2' c3') >>= unStorable


foreign import ccall
  hs_action_choix_trois ::  (ApiStorableType Int) -> (ApiStorableType Int) -> (ApiStorableType Int) -> IO (ApiStorableType Error)
-- Jouer l'action choisir entre deux paquets de deux cartes
action_choix_paquets :: Int ->  Int ->  Int ->  Int -> IO Error
action_choix_paquets p1c1  p1c2  p2c1  p2c2  = toStorable p1c1 $ \p1c1' ->  toStorable p1c2 $ \p1c2' ->  toStorable p2c1 $ \p2c1' ->  toStorable p2c2 $ \p2c2' ->  (hs_action_choix_paquets  p1c1' p1c2' p2c1' p2c2') >>= unStorable


foreign import ccall
  hs_action_choix_paquets ::  (ApiStorableType Int) -> (ApiStorableType Int) -> (ApiStorableType Int) -> (ApiStorableType Int) -> IO (ApiStorableType Error)
-- Choisir une des trois cartes proposées.
repondre_choix_trois :: Int -> IO Error
repondre_choix_trois c  = toStorable c $ \c' ->  (hs_repondre_choix_trois  c') >>= unStorable


foreign import ccall
  hs_repondre_choix_trois ::  (ApiStorableType Int) -> IO (ApiStorableType Error)
-- Choisir un des deux paquets proposés.
repondre_choix_paquets :: Int -> IO Error
repondre_choix_paquets p  = toStorable p $ \p' ->  (hs_repondre_choix_paquets  p') >>= unStorable


foreign import ccall
  hs_repondre_choix_paquets ::  (ApiStorableType Int) -> IO (ApiStorableType Error)
-- Affiche le contenu d'une valeur de type action
afficher_action :: Action -> IO ()
afficher_action v  = toStorable v $ \v' ->  (hs_afficher_action  v') >>= unStorable


foreign import ccall
  hs_afficher_action ::  (ApiStorableType Action) -> IO (ApiStorableType ())
-- Affiche le contenu d'une valeur de type error
afficher_error :: Error -> IO ()
afficher_error v  = toStorable v $ \v' ->  (hs_afficher_error  v') >>= unStorable


foreign import ccall
  hs_afficher_error ::  (ApiStorableType Error) -> IO (ApiStorableType ())
-- Affiche le contenu d'une valeur de type joueur
afficher_joueur :: Joueur -> IO ()
afficher_joueur v  = toStorable v $ \v' ->  (hs_afficher_joueur  v') >>= unStorable


foreign import ccall
  hs_afficher_joueur ::  (ApiStorableType Joueur) -> IO (ApiStorableType ())
-- Affiche le contenu d'une valeur de type action_jouee
afficher_action_jouee :: Action_jouee -> IO ()
afficher_action_jouee v  = toStorable v $ \v' ->  (hs_afficher_action_jouee  v') >>= unStorable


foreign import ccall
  hs_afficher_action_jouee ::  (ApiStorableType Action_jouee) -> IO (ApiStorableType ())
