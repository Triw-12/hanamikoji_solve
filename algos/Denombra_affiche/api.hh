// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2012-2020 Association Prologin <association@prologin.org>

// This file contains all the API functions for the C++ language, and all the
// constants, enumerations and structures.
// This file was generated by stechec2-generator. DO NOT EDIT.

#pragma once

#include <string>
#include <vector>

/// Les 7 Geisha (2, 2, 2, 3, 3, 4, 5)
#define NB_GEISHA 7

/// Le nombre total de cartes (2 + 2 + 2 + 3 + 3 + 4 + 5)
#define NB_CARTES_TOTALES 21

/// Le nombre de cartes que chaque personne a au début
#define NB_CARTES_DEBUT 6

/// Le nombre de cartes écartées au début du jeu
#define NB_CARTES_ECARTEES 1

/// Le nombre total d'actions que chaque joueur devra faire
#define NB_ACTIONS 4

/// Le nombre total de manches avant la fin de la partie
#define NB_MANCHES_MAX 3

/// La valeur (et le nombre de cartes) de chaque Geisha séparée par des |
#define GEISHA_VALEUR "2|2|2|3|3|4|5"

constexpr int GEISHA_VALEUR_INT[] = {2, 2, 2, 3, 3, 4, 5};
typedef int Cartes[NB_GEISHA];
typedef int *Cartesptr;

/// Les actions de jeu
typedef enum action {
  VALIDER,         ///< Valide une unique carte
  DEFAUSSER,       ///< Défausse deux cartes
  CHOIX_TROIS,     ///< Donne le choix entre trois cartes
  CHOIX_PAQUETS,   ///< Donne le choix entre deux paquets de deux cartes
  PREMIER_JOUEUR,  ///< Aucune action n'a été jouée (utilisé dans
                   ///< tour_precedent)
} action;

/// Enumeration contentant toutes les erreurs possibles
typedef enum error {
  OK,                 ///< pas d'erreur
  ACTION_DEJA_JOUEE,  ///< l'action a déjà été jouée
  CARTES_INVALIDES,   ///< vous ne pouvez pas jouer ces cartes
  PAQUET_INVALIDE,    ///< ce paquet n'existe pas
  GEISHA_INVALIDES,  ///< cette Geisha n'existe pas (doit être un entier entre 0
                     ///< et NB_GEISHA - 1)
  JOUEUR_INVALIDE,  ///< ce joueur n'existe pas
  CHOIX_INVALIDE,   ///< vous ne pouvez pas répondre à ce choix
  ACTION_INVALIDE,  ///< vous ne pouvez pas jouer cette action maintenant
} error;

/// Enumeration représentant les différents joueurs
typedef enum joueur {
  JOUEUR_1,  ///< Le joueur 1
  JOUEUR_2,  ///< Le joueur 2
  EGALITE,   ///< Égalité, utilisé uniquement dans possession_geisha
} joueur;

/// La description d'une action jouée
typedef struct action_jouee {
  action act;  ///< L'action jouée
  int c1;  ///< Si act==VALIDER ou act==DEFAUSSER, -1 sinon la première carte
           ///< (du premier paquet)
  int c2;  ///< Si act==V|D: -1 sinon la deuxième carte (du premier paquet)
  int c3;  ///< Si act==V|D: -1 sinon la troisième carte (ou la première carte
           ///< du second paquet si act==choix paquet)
  int c4;  ///< Si act!=choix paquet: -1 sinon la deuxième carte du second
           ///< paquet
} action_jouee;

/// Renvoie l'identifiant du joueur
joueur id_joueur();

/// Renvoie l'identifiant de l'adversaire
joueur id_adversaire();

/// Renvoie le numéro de la manche (entre 0 et 2)
int manche();

/// Renvoie le numéro du tour (entre 0 et 7)
int tour();

/// Renvoie l'action jouée par l'adversaire
action_jouee tour_precedent();

/// Renvoie le nombre de cartes validées par le joueur pour la Geisha (la carte
/// validée secrètement n'est pas prise en compte)
int nb_cartes_validees(joueur j, int g);

/// Renvoie qui possède la Geisha
joueur possession_geisha(int g);

/// Renvoie si l'action a déjà été jouée par le joueur
bool est_jouee_action(joueur j, action a);

/// Renvoie le nombre de cartes que le joueur a
int nb_cartes(joueur j);

/// Renvoie les cartes que vous avez
std::vector<int> cartes_en_main();

/// Renvoie la carte que vous avez piochée au début du tour
int carte_piochee();

/// Jouer l'action valider une carte
error action_valider(int c);

/// Jouer l'action défausser deux cartes
error action_defausser(int c1, int c2);

/// Jouer l'action choisir entre trois cartes
error action_choix_trois(int c1, int c2, int c3);

/// Jouer l'action choisir entre deux paquets de deux cartes
error action_choix_paquets(int p1c1, int p1c2, int p2c1, int p2c2);

/// Choisir une des trois cartes proposées.
error repondre_choix_trois(int c);

/// Choisir un des deux paquets proposés.
error repondre_choix_paquets(int p);

/// Affiche le contenu d'une valeur de type action
void afficher_action(action v);

/// Affiche le contenu d'une valeur de type error
void afficher_error(error v);

/// Affiche le contenu d'une valeur de type joueur
void afficher_joueur(joueur v);

/// Affiche le contenu d'une valeur de type action_jouee
void afficher_action_jouee(action_jouee v);

// -----
// API ends here, you can stop reading now.
// The rest of the file is generated operators for the structs defined above.
// -----

namespace std {
template <typename T>
struct hash<std::vector<T>> {
  std::size_t operator()(const std::vector<T>& v) const {
    std::size_t res = v.size();
    for (const auto& e : v)
      res ^= std::hash<T>()(e) + 0x9e3779b9 + (res << 6) + (res >> 2);
    return res;
  }
};
}  // namespace std

inline bool operator==(const action_jouee& a, const action_jouee& b) {
  if (a.act != b.act) return false;
  if (a.c1 != b.c1) return false;
  if (a.c2 != b.c2) return false;
  if (a.c3 != b.c3) return false;
  if (a.c4 != b.c4) return false;
  return true;
}

inline bool operator!=(const action_jouee& a, const action_jouee& b) {
  return !(a == b);
}

inline bool operator<(const action_jouee& a, const action_jouee& b) {
  if (a.act < b.act) return true;
  if (a.act > b.act) return false;
  if (a.c1 < b.c1) return true;
  if (a.c1 > b.c1) return false;
  if (a.c2 < b.c2) return true;
  if (a.c2 > b.c2) return false;
  if (a.c3 < b.c3) return true;
  if (a.c3 > b.c3) return false;
  if (a.c4 < b.c4) return true;
  if (a.c4 > b.c4) return false;
  return false;
}

inline bool operator>(const action_jouee& a, const action_jouee& b) {
  if (a.act > b.act) return true;
  if (a.act < b.act) return false;
  if (a.c1 > b.c1) return true;
  if (a.c1 < b.c1) return false;
  if (a.c2 > b.c2) return true;
  if (a.c2 < b.c2) return false;
  if (a.c3 > b.c3) return true;
  if (a.c3 < b.c3) return false;
  if (a.c4 > b.c4) return true;
  if (a.c4 < b.c4) return false;
  return false;
}

namespace std {
template <>
struct hash<action_jouee> {
  std::size_t operator()(const action_jouee& s) const {
    std::size_t res = 0;
    res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<action>()(s.act);
    res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.c1);
    res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.c2);
    res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.c3);
    res ^= 0x9e3779b9 + (res << 6) + (res >> 2) + std::hash<int>()(s.c4);
    return res;
  }
};
}  // namespace std

extern "C" {
void init_jeu();
void jouer_tour();
void repondre_action_choix_trois();
void repondre_action_choix_paquets();
void fin_jeu();
}
